// Generated by: main
// TypeWriter: sorted_container
// Directive: +gen on main.Id

// SortedSet is a modification of https://github.com/wfreeman/go-skiplist/sortedset.go
// The MIT License (MIT)
// Copyright (c) 2014 Wes Freeman (freeman.wes@gmail.com)

package main

import (
	"math"
	"math/rand"
)

// The primary type that represents a sorted set
// backed by a skiplist
type IdSortedSet struct {
	less      func(a, b Id) bool
	head      []*sortedSetIdElement
	length    int
	maxLevels int
	r         *rand.Rand
}

// the struct to hold elements of the skiplist
type sortedSetIdElement struct {
	val  Id
	next []*sortedSetIdElement
}

// Creates and returns a reference to an empty set.
func NewIdSortedSet(less func(Id, Id) bool) IdSortedSet {
	return IdSortedSet{
		less:      less,
		maxLevels: 64,
		head:      make([]*sortedSetIdElement, 64),
		r:         rand.New(rand.NewSource(123123)),
	}
}

func newSortedSetIdElement(v Id, levels int) *sortedSetIdElement {
	return &sortedSetIdElement{v, make([]*sortedSetIdElement, levels)}
}

// Creates and returns a reference to a set from an existing slice
func NewIdSortedSetFromSlice(less func(Id, Id) bool, s []Id) IdSortedSet {
	a := NewIdSortedSet(less)
	for _, item := range s {
		a.Add(item)
	}
	return a
}

func (ss IdSortedSet) randomLevels() int {
	level := int(math.Log(1.0-ss.r.Float64()) / math.Log(0.5))
	if level >= ss.maxLevels {
		level = ss.maxLevels
	}
	if level == 0 {
		level++
	}
	return level
}

// Adds an item to the current set if it doesn't already exist in the set.
func (ss IdSortedSet) Add(v Id) bool {
	var backPointer = make([]*sortedSetIdElement, 64)
	// zeroing this causes the compiler to not allocate memory each time
	// for a 20-30% boost in speed
	for i := 0; i < 64; i++ {
		backPointer[i] = nil
	}
	for level := ss.maxLevels - 1; level >= 0; level-- {
		var e *sortedSetIdElement = nil
		if level+1 == ss.maxLevels || backPointer[level+1] == nil {
			e = ss.head[level]
		} else {
			e = backPointer[level+1]
		}
		for e != nil {
			// if they are equal, overwrite?
			if ss.less(v, e.val) == ss.less(e.val, v) {
				return false
			}
			// if inspected val is greater than k, go back and down a level
			if ss.less(v, e.val) {
				break
			}
			backPointer[level] = e
			e = e.next[level]
		}
	}
	// create new element
	e := newSortedSetIdElement(v, ss.randomLevels())

	// connect new element up with backPointer
	for level := 0; level < len(e.next); level++ {
		if backPointer[level] == nil {
			e.next[level] = ss.head[level]
			ss.head[level] = e
		} else {
			e.next[level] = backPointer[level].next[level]
			backPointer[level].next[level] = e
		}
	}

	ss.length++
	return true
}

// Determines if a given item is already in the set.
func (ss IdSortedSet) Contains(v Id) bool {
	var backPointer = make([]*sortedSetIdElement, 64)
	// zeroing this causes the compiler to not allocate memory each time
	// for a 20-30% boost in speed
	for i := 0; i < 64; i++ {
		backPointer[i] = nil
	}
	for level := ss.maxLevels - 1; level >= 0; level-- {
		var e *sortedSetIdElement = nil
		if level+1 == ss.maxLevels || backPointer[level+1] == nil {
			e = ss.head[level]
		} else {
			e = backPointer[level+1]
		}
		for e != nil {
			// if they are equal, return val
			if ss.less(v, e.val) == ss.less(e.val, v) {
				return true
			}
			// if inspected val is greater than v, go back and down a level
			if ss.less(v, e.val) {
				break
			}
			backPointer[level] = e
			e = e.next[level]
		}
	}
	return false
}

// Determines if the given items are all in the set
func (ss IdSortedSet) ContainsAll(i ...Id) bool {
	for _, elem := range i {
		if !ss.Contains(elem) {
			return false
		}
	}
	return true
}

// Determines if every item in the other set is in this set.
func (ss IdSortedSet) IsSubset(other IdSortedSet) bool {
	e := ss.head[0]
	for e != nil {
		if !other.Contains(e.val) {
			return false
		}
		e = e.next[0]
	}
	return true
}

// Determines if every item of this set is in the other set.
func (ss IdSortedSet) IsSuperset(other IdSortedSet) bool {
	return other.IsSubset(ss)
}

// Returns a new set with all items in both sets.
func (ss IdSortedSet) Union(other IdSortedSet) IdSortedSet {
	unionedSet := NewIdSortedSet(ss.less)

	e := ss.head[0]
	for e != nil {
		unionedSet.Add(e.val)
		e = e.next[0]
	}
	e = other.head[0]
	for e != nil {
		unionedSet.Add(e.val)
		e = e.next[0]
	}
	return unionedSet
}

// Returns a new set with items that exist only in both sets.
func (ss IdSortedSet) Intersect(other IdSortedSet) IdSortedSet {
	intersection := NewIdSortedSet(ss.less)
	// loop over smaller set
	if ss.Cardinality() < other.Cardinality() {
		e := ss.head[0]
		for e != nil {
			if other.Contains(e.val) {
				intersection.Add(e.val)
			}
			e = e.next[0]
		}
	} else {
		e := other.head[0]
		for e != nil {
			if ss.Contains(e.val) {
				intersection.Add(e.val)
			}
			e = e.next[0]
		}
	}
	return intersection
}

// Returns a new set with items in the current set but not in the other set
func (ss IdSortedSet) Difference(other IdSortedSet) IdSortedSet {
	differencedSet := NewIdSortedSet(ss.less)
	e := ss.head[0]
	for e != nil {
		if !other.Contains(e.val) {
			differencedSet.Add(e.val)
		}
		e = e.next[0]
	}
	return differencedSet
}

// Returns a new set with items in the current set or the other set but not in both.
func (ss IdSortedSet) SymmetricDifference(other IdSortedSet) IdSortedSet {
	aDiff := ss.Difference(other)
	bDiff := other.Difference(ss)
	return aDiff.Union(bDiff)
}

// Clears the entire set to be the empty set.
func (ss *IdSortedSet) Clear() {
	*ss = IdSortedSet{
		less:      ss.less,
		maxLevels: 64,
		head:      make([]*sortedSetIdElement, 64),
		r:         rand.New(rand.NewSource(123123)),
	}
}

// Allows the removal of a single item in the set.
func (ss IdSortedSet) Remove(v Id) {
	var backPointer = make([]*sortedSetIdElement, 64)
	// zeroing this causes the compiler to not allocate memory each time
	// for a 20-30% boost in speed
	for i := 0; i < 64; i++ {
		backPointer[i] = nil
	}
	for level := ss.maxLevels - 1; level >= 0; level-- {
		var e *sortedSetIdElement = nil
		if level+1 == ss.maxLevels || backPointer[level+1] == nil {
			e = ss.head[level]
		} else {
			e = backPointer[level+1]
		}
		for e != nil {
			// if they are equal, remove
			if level == 0 && ss.less(v, e.val) == ss.less(e.val, v) {
				for level := 0; level < len(e.next); level++ {
					if backPointer[level] == nil {
						ss.head[level] = e.next[level]
					} else {
						backPointer[level].next[level] = e.next[level]
					}
				}

				ss.length--
			}
			if ss.less(v, e.val) == ss.less(e.val, v) {
				break
			}
			// if inspected val is greater than k, go back and down a level
			if ss.less(v, e.val) {
				break
			}
			backPointer[level] = e
			e = e.next[level]
		}
	}
}

// Cardinality returns how many items are currently in the set.
func (ss IdSortedSet) Cardinality() int {
	e := ss.head[0]
	ret := 0
	for e != nil {
		ret++
		e = e.next[0]
	}
	return ret
}

// Iter() returns a channel of type Id that you can range over.
func (ss IdSortedSet) Iter() <-chan Id {
	ch := make(chan Id)
	go func() {
		e := ss.head[0]
		for e != nil {
			ch <- e.val
			e = e.next[0]
		}
		close(ch)
	}()

	return ch
}

// Equal determines if two sets are equal to each other.
// If they both are the same size and have the same items they are considered equal.
// Order of items is not relevent for sets to be equal.
func (ss IdSortedSet) Equal(other IdSortedSet) bool {
	if ss.Cardinality() != other.Cardinality() {
		return false
	}
	e := ss.head[0]
	for e != nil {
		if !other.Contains(e.val) {
			return false
		}
		e = e.next[0]
	}
	return true
}

// Returns a clone of the set.
// Does NOT clone the underlying elements.
func (ss IdSortedSet) Clone() IdSortedSet {
	clonedSet := NewIdSortedSet(ss.less)
	e := ss.head[0]
	for e != nil {
		clonedSet.Add(e.val)
		e = e.next[0]
	}
	return clonedSet
}
